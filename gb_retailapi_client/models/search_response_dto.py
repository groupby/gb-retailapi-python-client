# coding: utf-8

"""
    GroupBy Retail

    GroupBy Retail API

    The version of the OpenAPI document: 0.0.0
    Contact: ops@groupbyinc.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
from gb_retailapi_client.models.debug_dto import DebugDto
from gb_retailapi_client.models.experiment import Experiment
from gb_retailapi_client.models.metadata import Metadata
from gb_retailapi_client.models.navigation_dto import NavigationDto
from gb_retailapi_client.models.page_info_dto import PageInfoDto
from gb_retailapi_client.models.record_dto import RecordDto
from gb_retailapi_client.models.search_metadata_dto import SearchMetadataDto
from gb_retailapi_client.models.search_request_dto import SearchRequestDto
from gb_retailapi_client.models.template_dto import TemplateDto

class SearchResponseDto(BaseModel):
    """
    Response of calling the search API, including various elements of the original request context, matching records and general metadata relating to the results.  # noqa: E501
    """
    id: Optional[StrictStr] = Field(None, description="Unique identifier for the search.")
    area: Optional[StrictStr] = Field(None, description="Area Id the search was performed in.")
    query: Optional[StrictStr] = Field(None, description="Original search query.")
    corrected_query: Optional[StrictStr] = Field(None, alias="correctedQuery", description="Search query after any changes/corrections are done by the engine.")
    biasing_profile: Optional[StrictStr] = Field(None, alias="biasingProfile", description="Name of the biasing profile which was used to bias products in the search results.")
    biasing_profile_applied_id: Optional[StrictInt] = Field(None, alias="biasingProfileAppliedId", description="Id of the biasing profile which was used to bias products in the search results.")
    filter: StrictStr = Field(...)
    original_request: SearchRequestDto = Field(..., alias="originalRequest")
    records: Optional[conlist(RecordDto)] = Field(None, description="The list of records that match the search.")
    total_record_count: Optional[StrictInt] = Field(None, alias="totalRecordCount", description="The total number of products that match the search. If all products were filtered out on S4R site equals to 0.")
    metadata: SearchMetadataDto = Field(...)
    page_info: PageInfoDto = Field(..., alias="pageInfo")
    available_navigation: conlist(NavigationDto) = Field(..., alias="availableNavigation")
    selected_navigation: conlist(NavigationDto) = Field(..., alias="selectedNavigation")
    redirect: Optional[StrictStr] = Field(None, description="URL to which the merchandiser should redirect the shopper to.")
    experiments: conlist(Experiment) = Field(...)
    template: TemplateDto = Field(...)
    empty: Optional[StrictBool] = Field(None, description="True if the search yielded no results, otherwise false.")
    site_params: conlist(Metadata) = Field(..., alias="siteParams")
    debug: DebugDto = Field(...)
    warnings: Optional[conlist(StrictStr)] = Field(None, description="Warning messages containing information about invalid products, etc.")
    include_expanded_results: Optional[StrictBool] = Field(None, alias="includeExpandedResults", description="When a shopper uses an ambiguous or a multi-word search phrase, they can get an empty response. After turning on include expanded results, Retail Search analyzes the request and returns the expanded list of products based on the parsed search query. For example, if you search \"Google Pixel 5\" without query expansion, you might only get \"google_pixel_5\" in the result. With query expansion, you might get \"google_pixel_4a_with_5g\", \"google_pixel_4a\" and \"google_pixel_5_case\" as well.The default value is configured in the tenant settings or true if there is no such setting")
    facet_limit: Optional[StrictInt] = Field(None, alias="facetLimit", description="Maximum of facet values that should be returned for this facet. If not specified, defaults to 20. The maximum allowed value is 300. Values above 300 will be coerced to 300.  If this field is negative, an INVALID_ARGUMENT is returned.  This limit (300) is configured on Google side, but Google have an ability to change it for specific project. ")
    redirect_metadata: conlist(Metadata) = Field(..., alias="redirectMetadata")
    __properties = ["id", "area", "query", "correctedQuery", "biasingProfile", "biasingProfileAppliedId", "filter", "originalRequest", "records", "totalRecordCount", "metadata", "pageInfo", "availableNavigation", "selectedNavigation", "redirect", "experiments", "template", "empty", "siteParams", "debug", "warnings", "includeExpandedResults", "facetLimit", "redirectMetadata"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> SearchResponseDto:
        """Create an instance of SearchResponseDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of original_request
        if self.original_request:
            _dict['originalRequest'] = self.original_request.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in records (list)
        _items = []
        if self.records:
            for _item in self.records:
                if _item:
                    _items.append(_item.to_dict())
            _dict['records'] = _items
        # override the default output from pydantic by calling `to_dict()` of metadata
        if self.metadata:
            _dict['metadata'] = self.metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of page_info
        if self.page_info:
            _dict['pageInfo'] = self.page_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in available_navigation (list)
        _items = []
        if self.available_navigation:
            for _item in self.available_navigation:
                if _item:
                    _items.append(_item.to_dict())
            _dict['availableNavigation'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in selected_navigation (list)
        _items = []
        if self.selected_navigation:
            for _item in self.selected_navigation:
                if _item:
                    _items.append(_item.to_dict())
            _dict['selectedNavigation'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in experiments (list)
        _items = []
        if self.experiments:
            for _item in self.experiments:
                if _item:
                    _items.append(_item.to_dict())
            _dict['experiments'] = _items
        # override the default output from pydantic by calling `to_dict()` of template
        if self.template:
            _dict['template'] = self.template.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in site_params (list)
        _items = []
        if self.site_params:
            for _item in self.site_params:
                if _item:
                    _items.append(_item.to_dict())
            _dict['siteParams'] = _items
        # override the default output from pydantic by calling `to_dict()` of debug
        if self.debug:
            _dict['debug'] = self.debug.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in redirect_metadata (list)
        _items = []
        if self.redirect_metadata:
            for _item in self.redirect_metadata:
                if _item:
                    _items.append(_item.to_dict())
            _dict['redirectMetadata'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> SearchResponseDto:
        """Create an instance of SearchResponseDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return SearchResponseDto.parse_obj(obj)

        _obj = SearchResponseDto.parse_obj({
            "id": obj.get("id"),
            "area": obj.get("area"),
            "query": obj.get("query"),
            "corrected_query": obj.get("correctedQuery"),
            "biasing_profile": obj.get("biasingProfile"),
            "biasing_profile_applied_id": obj.get("biasingProfileAppliedId"),
            "filter": obj.get("filter"),
            "original_request": SearchRequestDto.from_dict(obj.get("originalRequest")) if obj.get("originalRequest") is not None else None,
            "records": [RecordDto.from_dict(_item) for _item in obj.get("records")] if obj.get("records") is not None else None,
            "total_record_count": obj.get("totalRecordCount"),
            "metadata": SearchMetadataDto.from_dict(obj.get("metadata")) if obj.get("metadata") is not None else None,
            "page_info": PageInfoDto.from_dict(obj.get("pageInfo")) if obj.get("pageInfo") is not None else None,
            "available_navigation": [NavigationDto.from_dict(_item) for _item in obj.get("availableNavigation")] if obj.get("availableNavigation") is not None else None,
            "selected_navigation": [NavigationDto.from_dict(_item) for _item in obj.get("selectedNavigation")] if obj.get("selectedNavigation") is not None else None,
            "redirect": obj.get("redirect"),
            "experiments": [Experiment.from_dict(_item) for _item in obj.get("experiments")] if obj.get("experiments") is not None else None,
            "template": TemplateDto.from_dict(obj.get("template")) if obj.get("template") is not None else None,
            "empty": obj.get("empty"),
            "site_params": [Metadata.from_dict(_item) for _item in obj.get("siteParams")] if obj.get("siteParams") is not None else None,
            "debug": DebugDto.from_dict(obj.get("debug")) if obj.get("debug") is not None else None,
            "warnings": obj.get("warnings"),
            "include_expanded_results": obj.get("includeExpandedResults"),
            "facet_limit": obj.get("facetLimit"),
            "redirect_metadata": [Metadata.from_dict(_item) for _item in obj.get("redirectMetadata")] if obj.get("redirectMetadata") is not None else None
        })
        return _obj


